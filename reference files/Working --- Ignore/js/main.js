//Create a hand for the player and for the cpu

class Card { 
    constructor(card_name, card_type, card_power, card_health) { //<--- cards have default properties like a name, a type, attack/defense, and later a sprite if we add that
        this._name = card_name
        this._type = card_type
        this._attack = card_power
        this.defense = card_health
    }
    
}

const generatedCards = [] //<--- this is the array we push the 10 cards into at the start of our game. It is generated by our server side code and 
const cpuActive = []
const userActive = []
const cpuGraveyard = []
const userGraveyard = []
const userCardElements = []


const nameDescriptors = ['Cackling', 'True-shot', 'Enraged', 'Hallowed', 'Tranquil', 'Grifter', 'Dire', 'Undead', 'Fledgling', 'Inspired']
const nameClasses = ['Swordsman', 'Sorcerer', 'Strongman', 'Monk', 'Juggler', 'Cleric', 'Sage', 'Magician', 'Proctor']
const cardTypes = ['Fighter', 'Tank', 'Assassin', 'Healer', 'Mage']
const playSteps = Array.from(document.querySelectorAll('.playStep'))
const endTurn = document.getElementById('endTurn')


endTurn.addEventListener('click', endUsersTurn)

function generateHand() { //<--- creates our first 10 cards
    for (let i=0; i<10; i++) { //<--- loop 10 times to create 10 cards
    let card_name = `${nameDescriptors[Math.floor(Math.random() * nameDescriptors.length)]}` + ' ' + `${nameClasses[Math.floor(Math.random() * nameClasses.length)]}` //<--- grab 2 values at random from our descriptor/class arrays
    let card_type = `${cardTypes[Math.floor(Math.random() * cardTypes.length)]}` 
    let card_power = Math.floor(Math.random() * 5 + 1) //<--- power cap at 5
    let card_health = Math.floor(Math.random() * 10 + 1) //<--- power cap at 10
    let generatedCard = new Card(card_name, card_type, card_power, card_health)
    generatedCards.push(generatedCard) //<--- push the newly generated cards into the array holding our cards
    }
    return generatedCards //<--- return our card array
}


//populate cards in the DOM

const usersHand = []//Array holding the card objects in the user's hand
const cpusHand = []//Array holding the card objects in the cpu's hand

document.getElementById('start_game').addEventListener('click', populatePlayers) //event listener to both start the game and populate the hands.

function populatePlayers() {
    this.style.visibility = 'hidden'
    generateHand() //<--- remove this when we figure out how to pull the value generated by this function from our async function on the server side. Is here for testing only
    for (a of generatedCards) { //<--- for each object in the list of generated cards that we pulled from our async function
        if (generatedCards.indexOf(a) < 5) { //<--- give the first 5 cards to the players hand
            usersHand.push(a)
        } else {
            cpusHand.push(a) //<--- give the last 5 cards to the cpu
        }
    }
    createDomObject(cpusHand, usersHand) //<--- run the function that creates our HTML representation of these card objects
} 


function createDomObject(cpusHand, usersHand){
    for (a of playSteps) {
        a.classList.remove('active_phase')
    }
    playSteps[0].classList.add('active_phase')
    const cpusHandSection = document.getElementById('cpus_hand') //<--- the section that holds each of the card object DOM elements
    const usersHandSection = document.getElementById('users_hand') //<--- the section that holds each of the card object DOM elements
    for (let i=0; i< cpusHand.length; i++) { // <--- iterate through the hand of the cpu
        let ul = document.createElement('ul') //<--- for each card in the hand create a Ul that represents the card
        let cardProperties = [cpusHand[i]._name, cpusHand[i]._type, cpusHand[i]._attack, cpusHand[i].defense] //<--- get the properties on each card
            for (a of cardProperties) { //<--- for each property
                let li = document.createElement('li') //<--- create an li element
                li.appendChild(document.createTextNode(`${a}`)) //<--- populate that element with the text from the card property
                li.classList.add(`index${cardProperties.indexOf(a)}`)//<--- give the li an class with its index for styling
                ul.appendChild(li) //<--- attach it to the card DOM object
                ul.classList.add('cardSlot', 'cpu') //<--- give the ul classes for styling
            } cpusHandSection.appendChild(ul) //<--- attach that card to the section that displays the cpus hand
        }
    for (let i=0; i< usersHand.length; i++) { // <--- iterate through the hand of the cpu
        let ul = document.createElement('ul') //<--- for each card in the hand create a Ul that represents the card
        let cardProperties = [usersHand[i]._name, usersHand[i]._type, usersHand[i]._attack, usersHand[i].defense] //<--- get the properties on each card
            for (a of cardProperties) { //<--- for each property
                let li = document.createElement('li') //<--- create an li element
                li.appendChild(document.createTextNode(`${a}`)) //<--- populate that element with the text from the card property
                li.classList.add(`index${cardProperties.indexOf(a)}`) //<--- give the li an class with its index for styling
                ul.appendChild(li) //<--- attach it to the card DOM object
                ul.classList.add('cardSlot', 'player') //<--- give the ul classes for styling
            } usersHandSection.appendChild(ul) //<--- attach that card to the section that displays the cpus hand
            userCardElements.push(ul)
        }
        for (a of userCardElements) {
            a.addEventListener('click', setSelectedCard)
    }
}

let selectedCard

function setSelectedCard(){
    for (a of playSteps) {
        a.classList.remove('active_phase')
    }
    playSteps[0].classList.add('finished_phase')
    playSteps[1].classList.add('active_phase')
    for (a of userCardElements) {
        a.classList.remove('selected_card')
    }
    selectedCard = this
    this.classList.add('selected_card')
    console.log(selectedCard)
    return selectedCard
}


function endUsersTurn(){
    for (a of playSteps) {
        a.classList.remove('active_phase')
    }
    playSteps[1].classList.add('finished_phase')
    playSteps[2].classList.add('active_phase')
}

/*Function for checking damage*/

function checkCardStatus(cpuActive, userActive){
    for (a of cpuActive) {
        if (a._defense <= 0) {
            cpuGraveyard.push(a)
            cpuActive.splice(indexOf(a))
            console.log(`${a._name} was sent to the graveyard!` )
        }
    }
}


// Assassin - small chance of instant kill
// fighter - small chance of double strike
// medic - heals each turn (random number)
// mage - chance of using a forcefield that prevents being hit
// tank - chance to roll reduced damage

//inside of the attack function:
let proc = Math.floor(Math.random) * 5 // <--- generate 10 possible numbers
/*

if (a._type == 'assassin') {
    if (previouslyProcced === true) {
        console.log(`${a._name} must rest this turn from it's special, and cannot attack. ${a._name} deals no damage this turn.`)
        a._damage = 0
    }
    if (proc === 1) { //<---- 1/10 chance for the special to proc
        a._damage === cpusActive[0]._defense
        console.log(`${a._name} activated it's special to hit a kill-shot for ${cpusActive[0]._defense}!`)
        console.log(`${a._name} must rest for a turn before attacking`)
        previouslyProcced = true;
    }
}


if (a.type == 'tank') {
    if (proc <= 5) {

    }
}

let turnCounter = 0


function runTurn(){
    let damageForTurn = 0
    if (turnCounter === 0) {
        console.log("Creatures can't attack on their first active turn. No damage is dealt")
        damageForTurn = 0
    } else {
        for (a of userActive) {
            if (userActive.indexOf(a) < turnCounter) {
                let damageForTurn = damageForTurn + a._attack
            }
        }
    }
}
*/